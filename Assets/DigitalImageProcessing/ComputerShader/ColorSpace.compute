//#pragma except_renderers d3d9
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ColorSpaceTransform
#define PI 3.1415926535897932384626433832795
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> Input;
RWTexture2D<float4> Result;

float Rgb2Luminance(Texture2D<float4> input,uint3 id)
{
    return  dot(input[id.xy], float4(0.305306011, 0.682171111, 0.012522878, 0));
}

float3 RGB2HSV(Texture2D<float4> input,uint3 id)
{
    float3 HSV =float3(0, 0, 0);

    float r = input[id.xy].r;
    float g = input[id.xy].g;
    float b = input[id.xy].b;

    float num = 0.5 * ((r - g) + (r - b));
    float den = sqrt(pow(r - g, 2.0) + (r - b) * (g - b));
    float H = acos(num / (den + 0.001));
    if (b > g)
        H = 2 * PI - H;
    H /= 2 * PI;


    float den2 = r + g + b;
    if (den2 == 0) den2 =0.001;
    float S = 1. - 3. / den2 * min(min(r, g), b);

    // float S = 0;
    // if (max(max(r, g), b) != 0)
    //     S = 1.0 - min(min(r, g), b) / max(max(r, g), b);


    if (S == 0)
        H = 0;
    //float V = max(max(r, g), b);
    float V = (r + g + b) / 3.0;

    HSV = float3(H, S, V);
    return HSV;
}


float3 HSV2RGB(float3 hsv)
{

    float H = hsv.x;
    float S = hsv.y;
    float V = hsv.z;
    
    H *= 2.0 * PI;
    
    float r = 0, g = 0, b = 0;
    if (H >= 0 && H < 2.0 / 3.0 * PI)
    {
        r = V * (1 + S * cos(H) / cos(PI / 3.0 - H));
        b = V * (1 - S);
        g = 3.0 * V - (r + b);
    }
    
    if (H >= 2.0 / 3.0 * PI && H < 4. / 3. * PI)
    {
        g = V * (1. + S * cos(H - 2. / 3. * PI) / cos(PI - H));
        r = V * (1 - S);
        b = 3. * V - (r + g);
    }
    
    if (H >= 4. / 3. * PI && H <= 2. * PI)
    {
        b = V * (1. + S * cos(H - 4. / 3. * PI) / cos(5. / 3. * PI - H));
        g = V * (1. - S);
        r = 3. * V - (b + g);
    }

    float3 rgb = float3(r, g, b);

    rgb = max(min(rgb,float3(1,1,1)), float3(0,0,0));

    return float3(rgb.x, rgb.y, rgb.z);
}




[numthreads(8,8,1)]
void ColorSpaceTransform (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

    float3 hsv= RGB2HSV(Input,id);
  
    hsv.y = smoothstep(0,1,hsv.y);

    Result[id.xy] = float4(HSV2RGB(hsv),1.0);
}
 
