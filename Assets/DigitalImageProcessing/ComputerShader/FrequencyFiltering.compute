//#pragma except_renderers d3d9
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel DFT


#define PI 3.1415926535897932384626433832795
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> input;
RWTexture2D<float4> Result;

RWTexture2D<float4> KernelHor;
RWTexture2D<float4> KernelVer;

int kernelSize;
float kernelSum;

//Texture2D<float2> complexData;

float Rgb2Luminance(Texture2D<float4> input,uint3 id)
{
    return  dot(input[id.xy], float4(0.305306011, 0.682171111, 0.012522878, 0));
}

float2 DataConvert(Texture2D<float4> input,uint3 id,bool isShift =false)
{
    float gray = Rgb2Luminance(input,id);
    return float2((isShift)?gray*pow(-1,id.x+id.y):gray,0);

}

//  #region BruteForce
//             //for (int v = 0; v < N; v++)
//             //{
//             //    for (int u = 0; u < M; u++)
//             //    {
//             //        Vector2 complex = Vector2.zero;
//             //        for (int y = 0; y < N; y++)
//             //        {
//             //            for (int x = 0; x < M; x++)
//             //            {
//             //                float c = texture.GetPixel(x, y).grayscale * Pow(-1, x + y);
//             //                float w = -2f * PI * (u * (float)x / M + v * (float)y / N);
//             //                Vector2 ex = new Vector2(Cos(w), Sin(w));
//             //                complex += c * ex;
//             //            }
//             //        }

//             //        float fc = 1f / M * Sqrt(Vector2.SqrMagnitude(complex));

//             //        float cc = 50f * Log(1 + Abs(fc));
//             //        // Color nc = new Color(cc, cc, cc);
//             //        Color nc = new Color(fc, fc, fc);
//             //        Debug.Log(nc);
//             //        output.SetPixel(u, v, nc);

//             //    }
//             //}
// #endregion

[numthreads(8,8,1)]
void DFT (uint3 id:SV_DispatchThreadID)
{
    //float2 res = float2(DataConvert(input,id));
    float2 complex = 0;
    for(int v =0;v<32;v++)
    {
        for (int u = 0 ;u <32;u++)
        {
             float  c = Rgb2Luminance(input,id);
             float w = -2.0*PI * (u * id.x/32+v*id.y/32);
             float2 ex = float2(cos(w),sin(w));
             complex += c * ex;

        }
    }
   
    float fc = 1.0 / 32.0 *length(complex);
    //float cc = 50.0 * log(1.0 + abs(fc));

    Result[id.xy] =float4(fc,fc,fc,1.0);

}





